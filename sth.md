# 算法分类与详细步骤

算法是解决特定问题的一系列清晰、明确的指令，是计算机科学的核心。它定义了如何将输入转化为输出，并具有确定性、有穷性和可行性等基本特征。算法的设计与分析旨在寻找高效、正确且易于实现的解决方案。根据问题的性质和解决思路，算法可以进行如下分类：

---

### **1. 排序算法**

排序算法的目的是将一组数据按照特定顺序（如升序或降序）重新排列。它们是计算机科学中最基础、最经典的算法之一。

*   **比较排序**：通过比较元素间的大小来确定顺序。
    1.  **冒泡排序**：
        *   步骤1：从数组的第一个元素开始，比较相邻的两个元素。
        *   步骤2：如果第一个元素比第二个元素大（升序排序），则交换它们的位置。
        *   步骤3：继续比较下一对相邻元素，直到数组的末尾。此时，最大的元素将位于数组的最后位置。
        *   步骤4：重复上述过程，但每次遍历的范围减少一个元素（因为每次遍历都会将当前最大的元素放到正确的位置）。
        *   步骤5：继续重复，直到整个数组排序完成。
    
    2.  **选择排序**：
        *   步骤1：将数组分为已排序部分和未排序部分，初始时已排序部分为空。
        *   步骤2：在未排序部分中找到最小（或最大）的元素。
        *   步骤3：将找到的最小（或最大）元素与未排序部分的第一个元素交换位置。
        *   步骤4：将已排序部分的边界扩展一个元素。
        *   步骤5：重复步骤2-4，直到整个数组排序完成。
    
    3.  **插入排序**：
        *   步骤1：将数组分为已排序部分和未排序部分，初始时已排序部分只包含第一个元素。
        *   步骤2：从未排序部分取出第一个元素。
        *   步骤3：在已排序部分从后向前扫描，找到该元素应该插入的位置。
        *   步骤4：将该位置之后的所有元素向后移动一个位置。
        *   步骤5：将取出的元素插入到正确的位置。
        *   步骤6：重复步骤2-5，直到整个数组排序完成。
    
    4.  **希尔排序**：
        *   步骤1：选择一个增量序列（如gap = n/2, n/4, ..., 1）。
        *   步骤2：对于每个增量gap，将数组分为gap个子序列，每个子序列包含相距gap的元素。
        *   步骤3：对每个子序列使用插入排序进行排序。
        *   步骤4：减小gap的值，重复步骤2-3。
        *   步骤5：当gap减小到1时，整个数组将基本有序，最后进行一次标准的插入排序完成排序。
    
    5.  **归并排序**：
        *   步骤1：如果数组长度大于1，则将数组分成两个大致相等的子数组。
        *   步骤2：递归地对左子数组进行归并排序。
        *   步骤3：递归地对右子数组进行归并排序。
        *   步骤4：合并两个已排序的子数组：
            *   创建一个临时数组来存放合并后的结果。
            *   比较两个子数组的第一个元素，将较小的元素放入临时数组，并移动该子数组的指针。
            *   重复上述过程，直到一个子数组中的所有元素都被放入临时数组。
            *   将另一个子数组中剩余的元素全部复制到临时数组。
            *   将临时数组中的元素复制回原数组。
        *   步骤5：返回排序后的数组。
        *   **特点**：时间复杂度稳定为O(n log n)，但需要O(n)的额外空间。是**稳定**的排序算法。
    
    6.  **快速排序**：
        *   步骤1：从数组中选择一个元素作为基准值（pivot）。
        *   步骤2：将数组分区，所有小于基准值的元素放在基准值的左边，所有大于基准值的元素放在基准值的右边。基准值位于其最终位置。
        *   步骤3：递归地对基准值左边的子数组进行快速排序。
        *   步骤4：递归地对基准值右边的子数组进行快速排序。
        *   步骤5：合并结果（实际上，由于是原地排序，不需要显式合并）。
        *   **特点**：平均时间复杂度为O(n log n)，最坏情况为O(n²)。是不**稳定**的排序算法。通过优化（如随机化基准）可以避免最坏情况。
    
    7.  **堆排序**：
        *   步骤1：将数组构建成一个大顶堆（或小顶堆）：
            *   从最后一个非叶子节点开始，调整每个子树使其满足堆的性质。
        *   步骤2：将堆顶元素（最大值）与堆的最后一个元素交换位置。
        *   步骤3：将堆的大小减1（排除已排序的最大元素）。
        *   步骤4：对剩余的元素重新调整，使其满足堆的性质。
        *   步骤5：重复步骤2-4，直到堆的大小为1，排序完成。
        *   **特点**：时间复杂度为O(n log n)，空间复杂度为O(1)。是不**稳定**的排序算法。

*   **非比较排序**：不通过直接比较来排序，在特定条件下效率更高。
    1.  **计数排序**：
        *   步骤1：找出数组中的最大值，确定数据的范围。
        *   步骤2：创建一个计数数组，大小为最大值加1，初始值都为0。
        *   步骤3：遍历原始数组，统计每个元素出现的次数，并在计数数组的对应位置增加计数。
        *   步骤4：对计数数组进行变形，使每个位置的值等于其前面所有位置值的和（这样每个位置的值就表示该元素在排序后数组中的最后位置）。
        *   步骤5：创建一个与原始数组大小相同的临时数组。
        *   步骤6：从后向前遍历原始数组，根据计数数组确定每个元素在排序后数组中的位置，并将其放入临时数组的对应位置。
        *   步骤7：将临时数组复制回原始数组，排序完成。
    
    2.  **桶排序**：
        *   步骤1：确定桶的数量，并根据数据的分布情况将数据分配到不同的桶中。
        *   步骤2：遍历原始数组，将每个元素根据映射函数放入对应的桶中。
        *   步骤3：对每个非空桶单独进行排序（可以使用插入排序或其他排序算法）。
        *   步骤4：按顺序将所有桶中的元素合并，得到排序后的数组。
    
    3.  **基数排序**：
        *   步骤1：找出数组中的最大数，确定最大位数。
        *   步骤2：从最低位（个位）开始，对每一位进行计数排序：
            *   根据当前位的值将元素分配到不同的桶中（0-9）。
            *   按桶的顺序收集元素，形成新的数组。
        *   步骤3：对更高位重复步骤2，直到处理完所有位数。
        *   步骤4：最终得到的数组即为排序后的数组。

---

### **2. 查找算法**

查找算法用于在数据集合中定位一个或一组满足特定条件的元素。

1.  **线性查找**：
    *   步骤1：从数组的第一个元素开始。
    *   步骤2：将当前元素与目标值进行比较。
    *   步骤3：如果当前元素等于目标值，返回其索引。
    *   步骤4：如果当前元素不等于目标值，移动到下一个元素。
    *   步骤5：重复步骤2-4，直到找到目标值或遍历完整个数组。
    *   步骤6：如果遍历完整个数组都没有找到目标值，返回未找到的标识（如-1）。
    *   **适用场景**：无序或未排序的数据。时间复杂度为O(n)。

2.  **二分查找**：
    *   步骤1：确定查找范围的起始点（low）和结束点（high），初始时low为0，high为数组长度减1。
    *   步骤2：计算中间位置mid = low + (high - low) / 2。
    *   步骤3：比较中间位置的元素与目标值：
        *   如果中间元素等于目标值，返回mid。
        *   如果中间元素小于目标值，将low设置为mid + 1，在右半部分继续查找。
        *   如果中间元素大于目标值，将high设置为mid - 1，在左半部分继续查找。
    *   步骤4：重复步骤2-3，直到找到目标值或low大于high。
    *   步骤5：如果low大于high，说明未找到目标值，返回未找到的标识（如-1）。
    *   **适用场景**：有序数组。时间复杂度为O(log n)。

3.  **哈希查找**：
    *   步骤1：通过哈希函数将关键字转换为哈希表中的索引位置。
    *   步骤2：访问该索引位置，检查存储的元素是否与目标值匹配。
    *   步骤3：如果匹配，返回该元素。
    *   步骤4：如果不匹配（发生哈希冲突），使用冲突解决方法（如链地址法或开放地址法）继续查找。
    *   步骤5：重复步骤2-4，直到找到目标值或确定目标值不存在于哈希表中。
    *   **适用场景**：需要快速插入、删除和查找的场景。
    *   **时间复杂度**：平均为O(1)，但在哈希冲突严重时可能退化为O(n)。

---

### **3. 图算法**

图算法处理由顶点（节点）和边组成的图结构数据，广泛应用于社交网络、路径规划、网络分析等领域。

1.  **图遍历**：
    *   **深度优先搜索**：
        *   步骤1：选择一个起始顶点，将其标记为已访问，并将其加入栈中。
        *   步骤2：当栈不为空时，从栈顶取出一个顶点作为当前顶点。
        *   步骤3：访问当前顶点的所有邻接顶点：
            *   如果邻接顶点未被访问，将其标记为已访问，并将其加入栈中。
        *   步骤4：重复步骤2-3，直到栈为空。
        *   步骤5：如果图中仍有未访问的顶点，选择一个未访问的顶点作为新的起始顶点，重复步骤1-4。
    
    *   **广度优先搜索**：
        *   步骤1：选择一个起始顶点，将其标记为已访问，并将其加入队列中。
        *   步骤2：当队列不为空时，从队列头部取出一个顶点作为当前顶点。
        *   步骤3：访问当前顶点的所有邻接顶点：
            *   如果邻接顶点未被访问，将其标记为已访问，并将其加入队列尾部。
        *   步骤4：重复步骤2-3，直到队列为空。
        *   步骤5：如果图中仍有未访问的顶点，选择一个未访问的顶点作为新的起始顶点，重复步骤1-4。
        *   **适用场景**：寻找无权图的最短路径。

2.  **最短路径算法**：
    *   **Dijkstra算法**：
        *   步骤1：初始化：
            *   创建一个距离数组dist[]，初始时源点到自身的距离为0，到其他所有顶点的距离为无穷大。
            *   创建一个集合S，初始为空，用于存放已找到最短路径的顶点。
            *   创建一个优先队列（或最小堆），初始时包含源点及其距离0。
        *   步骤2：当优先队列不为空时：
            *   从优先队列中取出距离最小的顶点u，将其加入集合S。
            *   对于u的每个邻接顶点v：
                *   计算从源点经过u到v的距离newDist = dist[u] + 边(u, v)的权重。
                *   如果newDist小于dist[v]，则更新dist[v] = newDist，并将v及其新距离加入优先队列。
        *   步骤3：重复步骤2，直到优先队列为空或所有顶点都已加入集合S。
        *   步骤4：距离数组dist[]中存储的就是从源点到各个顶点的最短距离。
        *   **适用场景**：所有边权为非负值的图。
    
    *   **Bellman-Ford算法**：
        *   步骤1：初始化：
            *   创建一个距离数组dist[]，初始时源点到自身的距离为0，到其他所有顶点的距离为无穷大。
        *   步骤2：对所有边进行V-1次松弛操作（V是顶点数）：
            *   对于每条边(u, v)：
                *   如果dist[u] + 边(u, v)的权重 < dist[v]，则更新dist[v] = dist[u] + 边(u, v)的权重。
        *   步骤3：检查是否存在负权环：
            *   对所有边再进行一次松弛操作。
            *   如果还能更新任何顶点的距离，则说明图中存在负权环。
        *   步骤4：如果不存在负权环，距离数组dist[]中存储的就是从源点到各个顶点的最短距离。
        *   **适用场景**：可以处理边权为负值的情况，并能检测图中是否存在负权环。
    
    *   **Floyd-Warshall算法**：
        *   步骤1：初始化一个距离矩阵dist[][]，其中dist[i][j]表示从顶点i到顶点j的距离：
            *   如果i == j，则dist[i][j] = 0。
            *   如果i和j之间有边，则dist[i][j] = 边的权重。
            *   否则，dist[i][j] = 无穷大。
        *   步骤2：对于每个中间顶点k（从0到V-1）：
            *   对于每对顶点(i, j)：
                *   如果dist[i][k] + dist[k][j] < dist[i][j]，则更新dist[i][j] = dist[i][k] + dist[k][j]。
        *   步骤3：重复步骤2，直到考虑所有中间顶点。
        *   步骤4：最终的距离矩阵dist[][]中存储的就是所有顶点对之间的最短距离。
        *   **适用场景**：计算图中所有顶点对之间的最短路径，可以处理负权边，但不能处理负权环。

3.  **最小生成树**：在连通的加权无向图中，找到一个包含所有顶点的、边的权重之和最小的子图（树）。
    *   **Prim算法**：
        *   步骤1：初始化：
            *   选择一个起始顶点，将其加入最小生成树集合MST。
            *   创建一个键值数组key[]，用于存储每个顶点到MST的最小距离，初始时起始顶点的key值为0，其他为无穷大。
            *   创建一个布尔数组mstSet[]，用于标记顶点是否已加入MST，初始时都为false。
        *   步骤2：当MST中的顶点数小于总顶点数时：
            *   从未加入MST的顶点中选择key值最小的顶点u，将其加入MST。
            *   对于u的每个邻接顶点v：
                *   如果v未加入MST且边(u, v)的权重小于v的key值，则更新key[v] = 边(u, v)的权重。
        *   步骤3：重复步骤2，直到所有顶点都加入MST。
        *   步骤4：最终得到的最小生成树包含所有顶点和连接它们的边。
        *   **适用场景**：适合稠密图。
    
    *   **Kruskal算法
