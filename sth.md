# 算法分类与详细步骤

算法是解决特定问题的一系列清晰、明确的指令，是计算机科学的核心。它定义了如何将输入转化为输出，并具有确定性、有穷性和可行性等基本特征。算法的设计与分析旨在寻找高效、正确且易于实现的解决方案。根据问题的性质和解决思路，算法可以进行如下分类：

---

### **1. 排序算法**

排序算法的目的是将一组数据按照特定顺序（如升序或降序）重新排列。它们是计算机科学中最基础、最经典的算法之一。

*   **比较排序**：通过比较元素间的大小来确定顺序。
    1.  **冒泡排序**：
        *   步骤1：从数组的第一个元素开始，比较相邻的两个元素。
        *   步骤2：如果第一个元素比第二个元素大（升序排序），则交换它们的位置。
        *   步骤3：继续比较下一对相邻元素，直到数组的末尾。此时，最大的元素将位于数组的最后位置。
        *   步骤4：重复上述过程，但每次遍历的范围减少一个元素（因为每次遍历都会将当前最大的元素放到正确的位置）。
        *   步骤5：继续重复，直到整个数组排序完成。
    
    2.  **选择排序**：
        *   步骤1：将数组分为已排序部分和未排序部分，初始时已排序部分为空。
        *   步骤2：在未排序部分中找到最小（或最大）的元素。
        *   步骤3：将找到的最小（或最大）元素与未排序部分的第一个元素交换位置。
        *   步骤4：将已排序部分的边界扩展一个元素。
        *   步骤5：重复步骤2-4，直到整个数组排序完成。
    
    3.  **插入排序**：
        *   步骤1：将数组分为已排序部分和未排序部分，初始时已排序部分只包含第一个元素。
        *   步骤2：从未排序部分取出第一个元素。
        *   步骤3：在已排序部分从后向前扫描，找到该元素应该插入的位置。
        *   步骤4：将该位置之后的所有元素向后移动一个位置。
        *   步骤5：将取出的元素插入到正确的位置。
        *   步骤6：重复步骤2-5，直到整个数组排序完成。
    
    4.  **希尔排序**：
        *   步骤1：选择一个增量序列（如gap = n/2, n/4, ..., 1）。
        *   步骤2：对于每个增量gap，将数组分为gap个子序列，每个子序列包含相距gap的元素。
        *   步骤3：对每个子序列使用插入排序进行排序。
        *   步骤4：减小gap的值，重复步骤2-3。
        *   步骤5：当gap减小到1时，整个数组将基本有序，最后进行一次标准的插入排序完成排序。
    
    5.  **归并排序**：
        *   步骤1：如果数组长度大于1，则将数组分成两个大致相等的子数组。
        *   步骤2：递归地对左子数组进行归并排序。
        *   步骤3：递归地对右子数组进行归并排序。
        *   步骤4：合并两个已排序的子数组：
            *   创建一个临时数组来存放合并后的结果。
            *   比较两个子数组的第一个元素，将较小的元素放入临时数组，并移动该子数组的指针。
            *   重复上述过程，直到一个子数组中的所有元素都被放入临时数组。
            *   将另一个子数组中剩余的元素全部复制到临时数组。
            *   将临时数组中的元素复制回原数组。
        *   步骤5：返回排序后的数组。
        *   **特点**：时间复杂度稳定为O(n log n)，但需要O(n)的额外空间。是**稳定**的排序算法。
    
    6.  **快速排序**：
        *   步骤1：从数组中选择一个元素作为基准值（pivot）。
        *   步骤2：将数组分区，所有小于基准值的元素放在基准值的左边，所有大于基准值的元素放在基准值的右边。基准值位于其最终位置。
        *   步骤3：递归地对基准值左边的子数组进行快速排序。
        *   步骤4：递归地对基准值右边的子数组进行快速排序。
        *   步骤5：合并结果（实际上，由于是原地排序，不需要显式合并）。
        *   **特点**：平均时间复杂度为O(n log n)，最坏情况为O(n²)。是不**稳定**的排序算法。通过优化（如随机化基准）可以避免最坏情况。
    
    7.  **堆排序**：
        *   步骤1：将数组构建成一个大顶堆（或小顶堆）：
            *   从最后一个非叶子节点开始，调整每个子树使其满足堆的性质。
        *   步骤2：将堆顶元素（最大值）与堆的最后一个元素交换位置。
        *   步骤3：将堆的大小减1（排除已排序的最大元素）。
        *   步骤4：对剩余的元素重新调整，使其满足堆的性质。
        *   步骤5：重复步骤2-4，直到堆的大小为1，排序完成。
        *   **特点**：时间复杂度为O(n log n)，空间复杂度为O(1)。是不**稳定**的排序算法。

*   **非比较排序**：不通过直接比较来排序，在特定条件下效率更高。
    1.  **计数排序**：
        *   步骤1：找出数组中的最大值，确定数据的范围。
        *   步骤2：创建一个计数数组，大小为最大值加1，初始值都为0。
        *   步骤3：遍历原始数组，统计每个元素出现的次数，并在计数数组的对应位置增加计数。
        *   步骤4：对计数数组进行变形，使每个位置的值等于其前面所有位置值的和（这样每个位置的值就表示该元素在排序后数组中的最后位置）。
        *   步骤5：创建一个与原始数组大小相同的临时数组。
        *   步骤6：从后向前遍历原始数组，根据计数数组确定每个元素在排序后数组中的位置，并将其放入临时数组的对应位置。
        *   步骤7：将临时数组复制回原始数组，排序完成。
    
    2.  **桶排序**：
        *   步骤1：确定桶的数量，并根据数据的分布情况将数据分配到不同的桶中。
        *   步骤2：遍历原始数组，将每个元素根据映射函数放入对应的桶中。
        *   步骤3：对每个非空桶单独进行排序（可以使用插入排序或其他排序算法）。
        *   步骤4：按顺序将所有桶中的元素合并，得到排序后的数组。
    
    3.  **基数排序**：
        *   步骤1：找出数组中的最大数，确定最大位数。
        *   步骤2：从最低位（个位）开始，对每一位进行计数排序：
            *   根据当前位的值将元素分配到不同的桶中（0-9）。
            *   按桶的顺序收集元素，形成新的数组。
        *   步骤3：对更高位重复步骤2，直到处理完所有位数。
        *   步骤4：最终得到的数组即为排序后的数组。

---

### **2. 查找算法**

查找算法用于在数据集合中定位一个或一组满足特定条件的元素。

1.  **线性查找**：
    *   步骤1：从数组的第一个元素开始。
    *   步骤2：将当前元素与目标值进行比较。
    *   步骤3：如果当前元素等于目标值，返回其索引。
    *   步骤4：如果当前元素不等于目标值，移动到下一个元素。
    *   步骤5：重复步骤2-4，直到找到目标值或遍历完整个数组。
    *   步骤6：如果遍历完整个数组都没有找到目标值，返回未找到的标识（如-1）。
    *   **适用场景**：无序或未排序的数据。时间复杂度为O(n)。

2.  **二分查找**：
    *   步骤1：确定查找范围的起始点（low）和结束点（high），初始时low为0，high为数组长度减1。
    *   步骤2：计算中间位置mid = low + (high - low) / 2。
    *   步骤3：比较中间位置的元素与目标值：
        *   如果中间元素等于目标值，返回mid。
        *   如果中间元素小于目标值，将low设置为mid + 1，在右半部分继续查找。
        *   如果中间元素大于目标值，将high设置为mid - 1，在左半部分继续查找。
    *   步骤4：重复步骤2-3，直到找到目标值或low大于high。
    *   步骤5：如果low大于high，说明未找到目标值，返回未找到的标识（如-1）。
    *   **适用场景**：有序数组。时间复杂度为O(log n)。

3.  **哈希查找**：
    *   步骤1：通过哈希函数将关键字转换为哈希表中的索引位置。
    *   步骤2：访问该索引位置，检查存储的元素是否与目标值匹配。
    *   步骤3：如果匹配，返回该元素。
    *   步骤4：如果不匹配（发生哈希冲突），使用冲突解决方法（如链地址法或开放地址法）继续查找。
    *   步骤5：重复步骤2-4，直到找到目标值或确定目标值不存在于哈希表中。
    *   **适用场景**：需要快速插入、删除和查找的场景。
    *   **时间复杂度**：平均为O(1)，但在哈希冲突严重时可能退化为O(n)。

---

### **3. 图算法**

图算法处理由顶点（节点）和边组成的图结构数据，广泛应用于社交网络、路径规划、网络分析等领域。

1.  **图遍历**：
    *   **深度优先搜索**：
        *   步骤1：选择一个起始顶点，将其标记为已访问，并将其加入栈中。
        *   步骤2：当栈不为空时，从栈顶取出一个顶点作为当前顶点。
        *   步骤3：访问当前顶点的所有邻接顶点：
            *   如果邻接顶点未被访问，将其标记为已访问，并将其加入栈中。
        *   步骤4：重复步骤2-3，直到栈为空。
        *   步骤5：如果图中仍有未访问的顶点，选择一个未访问的顶点作为新的起始顶点，重复步骤1-4。
    
    *   **广度优先搜索**：
        *   步骤1：选择一个起始顶点，将其标记为已访问，并将其加入队列中。
        *   步骤2：当队列不为空时，从队列头部取出一个顶点作为当前顶点。
        *   步骤3：访问当前顶点的所有邻接顶点：
            *   如果邻接顶点未被访问，将其标记为已访问，并将其加入队列尾部。
        *   步骤4：重复步骤2-3，直到队列为空。
        *   步骤5：如果图中仍有未访问的顶点，选择一个未访问的顶点作为新的起始顶点，重复步骤1-4。
        *   **适用场景**：寻找无权图的最短路径。

2.  **最短路径算法**：
    *   **Dijkstra算法**：
        *   步骤1：初始化：
            *   创建一个距离数组dist[]，初始时源点到自身的距离为0，到其他所有顶点的距离为无穷大。
            *   创建一个集合S，初始为空，用于存放已找到最短路径的顶点。
            *   创建一个优先队列（或最小堆），初始时包含源点及其距离0。
        *   步骤2：当优先队列不为空时：
            *   从优先队列中取出距离最小的顶点u，将其加入集合S。
            *   对于u的每个邻接顶点v：
                *   计算从源点经过u到v的距离newDist = dist[u] + 边(u, v)的权重。
                *   如果newDist小于dist[v]，则更新dist[v] = newDist，并将v及其新距离加入优先队列。
        *   步骤3：重复步骤2，直到优先队列为空或所有顶点都已加入集合S。
        *   步骤4：距离数组dist[]中存储的就是从源点到各个顶点的最短距离。
        *   **适用场景**：所有边权为非负值的图。
    
    *   **Bellman-Ford算法**：
        *   步骤1：初始化：
            *   创建一个距离数组dist[]，初始时源点到自身的距离为0，到其他所有顶点的距离为无穷大。
        *   步骤2：对所有边进行V-1次松弛操作（V是顶点数）：
            *   对于每条边(u, v)：
                *   如果dist[u] + 边(u, v)的权重 < dist[v]，则更新dist[v] = dist[u] + 边(u, v)的权重。
        *   步骤3：检查是否存在负权环：
            *   对所有边再进行一次松弛操作。
            *   如果还能更新任何顶点的距离，则说明图中存在负权环。
        *   步骤4：如果不存在负权环，距离数组dist[]中存储的就是从源点到各个顶点的最短距离。
        *   **适用场景**：可以处理边权为负值的情况，并能检测图中是否存在负权环。
    
    *   **Floyd-Warshall算法**：
        *   步骤1：初始化一个距离矩阵dist[][]，其中dist[i][j]表示从顶点i到顶点j的距离：
            *   如果i == j，则dist[i][j] = 0。
            *   如果i和j之间有边，则dist[i][j] = 边的权重。
            *   否则，dist[i][j] = 无穷大。
        *   步骤2：对于每个中间顶点k（从0到V-1）：
            *   对于每对顶点(i, j)：
                *   如果dist[i][k] + dist[k][j] < dist[i][j]，则更新dist[i][j] = dist[i][k] + dist[k][j]。
        *   步骤3：重复步骤2，直到考虑所有中间顶点。
        *   步骤4：最终的距离矩阵dist[][]中存储的就是所有顶点对之间的最短距离。
        *   **适用场景**：计算图中所有顶点对之间的最短路径，可以处理负权边，但不能处理负权环。

3.  **最小生成树**：在连通的加权无向图中，找到一个包含所有顶点的、边的权重之和最小的子图（树）。
    *   **Prim算法**：
        *   步骤1：初始化：
            *   选择一个起始顶点，将其加入最小生成树集合MST。
            *   创建一个键值数组key[]，用于存储每个顶点到MST的最小距离，初始时起始顶点的key值为0，其他为无穷大。
            *   创建一个布尔数组mstSet[]，用于标记顶点是否已加入MST，初始时都为false。
        *   步骤2：当MST中的顶点数小于总顶点数时：
            *   从未加入MST的顶点中选择key值最小的顶点u，将其加入MST。
            *   对于u的每个邻接顶点v：
                *   如果v未加入MST且边(u, v)的权重小于v的key值，则更新key[v] = 边(u, v)的权重。
        *   步骤3：重复步骤2，直到所有顶点都加入MST。
        *   步骤4：最终得到的最小生成树包含所有顶点和连接它们的边。
        *   **适用场景**：适合稠密图。
    
    *   **Kruskal算法**：
        *   步骤1：初始化：
            *   创建一个集合，初始时包含所有顶点，每个顶点自成一个集合。
            *   将所有边按权重从小到大排序。
        *   步骤2：按顺序考虑每条边(u, v)：
            *   找到u所属的集合和v所属的集合。
            *   如果u和v不属于同一个集合（即加入这条边不会形成环），则将这条边加入最小生成树，并合并u和v所属的集合。
        *   步骤3：重复步骤2，直到最小生成树包含V-1条边（V是顶点数）或所有边都被考虑。
        *   步骤4：最终得到的最小生成树包含所有顶点和连接它们的边。
        *   **适用场景**：适合稀疏图。

4.  **拓扑排序**：对**有向无环图（DAG）**的顶点进行线性排序，使得对于图中每条有向边，起点都在终点之前。常用于任务调度、依赖关系分析。
    *   **基于DFS的拓扑排序**：
        *   步骤1：计算每个顶点的入度（指向该顶点的边的数量）。
        *   步骤2：将所有入度为0的顶点加入一个队列。
        *   步骤3：当队列不为空时：
            *   从队列中取出一个顶点u，将其加入拓扑排序结果。
            *   对于u的每个邻接顶点v：
                *   将v的入度减1。
                *   如果v的入度变为0，将v加入队列。
        *   步骤4：重复步骤3，直到队列为空。
        *   步骤5：如果拓扑排序结果中的顶点数等于图中的顶点数，则拓扑排序成功；否则，图中存在环，无法进行拓扑排序。

---

### **4. 动态规划**

动态规划是一种通过将复杂问题分解为更小的、重叠的子问题来求解的优化方法。它通过存储子问题的解（避免重复计算），从而高效地求出原问题的解。

*   **核心思想**：
    *   **最优子结构**：问题的最优解包含其子问题的最优解。
    *   **重叠子问题**：在递归求解过程中，许多子问题会被重复计算多次。
*   **解题步骤**：
    1.  刻画最优解的结构，并定义状态。
    2.  递归地定义最优值（写出状态转移方程）。
    3.  计算最优值（通常自底向上地填写表格）。
    4.  根据计算出的信息构造最优解。
*   **经典问题**：
    *   **0-1背包问题**：
        *   **问题描述**：有N件物品和一个容量为W的背包。第i件物品的重量是weight[i]，价值是value[i]。求解将哪些物品装入背包可使这些物品的总重量不超过背包容量，且总价值最大。
        *   **步骤**：
            1.  **定义状态**：创建一个二维数组dp[i][w]，表示前i件物品放入容量为w的背包中所能获得的最大价值。
            2.  **初始化**：dp[0][w] = 0（0件物品的价值为0），dp[i][0] = 0（容量为0时无法放入任何物品）。
            3.  **状态转移方程**：
                *   对于第i件物品（重量为weight[i-1]，价值为value[i-1]）：
                    *   如果weight[i-1] > w（当前物品重量大于背包容量），则不能放入该物品：dp[i][w] = dp[i-1][w]。
                    *   否则，可以选择放入或不放入该物品，取价值较大的那个：dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i-1]] + value[i-1])。
            4.  **填表**：按行或按列顺序填充dp数组。
            5.  **结果**：dp[N][W]即为所求的最大价值。
    
    *   **最长公共子序列**：
        *   **问题描述**：给定两个字符串text1和text2，找出它们的最长公共子序列的长度。一个子序列是指在不改变剩余字符顺序的情况下，从原字符串中删除一些字符（也可以不删除任何字符）后形成的新字符串。
        *   **步骤**：
            1.  **定义状态**：创建一个二维数组dp[i][j]，表示text1的前i个字符和text2的前j个字符的最长公共子序列的长度。
            2.  **初始化**：dp[0][j] = 0（text1为空字符串），dp[i][0] = 0（text2为空字符串）。
            3.  **状态转移方程**：
                *   如果text1[i-1] == text2[j-1]（当前字符相同），则dp[i][j] = dp[i-1][j-1] + 1。
                *   否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])（取text1去掉当前字符或text2去掉当前字符的较大值）。
            4.  **填表**：按行或按列顺序填充dp数组。
            5.  **结果**：dp[m][n]即为所求的最长公共子序列的长度，其中m和n分别是text1和text2的长度。
    
    *   **最长递增子序列**：
        *   **问题描述**：给定一个整数数组nums，找到其中最长严格递增子序列的长度。
        *   **步骤**：
            1.  **定义状态**：创建一个数组dp[i]，表示以nums[i]结尾的最长递增子序列的长度。
            2.  **初始化**：dp[i] = 1（每个元素本身就是一个递增子序列）。
            3.  **状态转移方程**：
                *   对于每个i，遍历所有j < i：
                    *   如果nums[j] < nums[i]，则dp[i] = max(dp[i], dp[j] + 1)。
            4.  **填表**：按顺序填充dp数组。
            5.  **结果**：dp数组中的最大值即为所求的最长递增子序列的长度。
    
    *   **编辑距离**：
        *   **问题描述**：给定两个字符串word1和word2，计算出将word1转换成word2所使用的最少操作次数。可以进行的操作包括插入一个字符、删除一个字符或替换一个字符。
        *   **步骤**：
            1.  **定义状态**：创建一个二维数组dp[i][j]，表示将word1的前i个字符转换成word2的前j个字符所需的最少操作次数。
            2.  **初始化**：
                *   dp[0][j] = j（将空字符串转换成word2的前j个字符需要j次插入操作）。
                *   dp[i][0] = i（将word1的前i个字符转换成空字符串需要i次删除操作）。
            3.  **状态转移方程**：
                *   如果word1[i-1] == word2[j-1]（当前字符相同），则dp[i][j] = dp[i-1][j-1]（不需要操作）。
                *   否则，dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)（分别对应删除、插入和替换操作）。
            4.  **填表**：按行或按列顺序填充dp数组。
            5.  **结果**：dp[m][n]即为所求的编辑距离，其中m和n分别是word1和word2的长度。
    
    *   **斐波那契数列**（作为讲解重叠子问题的经典案例）：
        *   **问题描述**：计算斐波那契数列的第n项。斐波那契数列的定义为：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)（n > 1）。
        *   **步骤**：
            1.  **定义状态**：创建一个数组dp[i]，表示斐波那契数列的第i项。
            2.  **初始化**：dp[0] = 0, dp[1] = 1。
            3.  **状态转移方程**：dp[i] = dp[i-1] + dp[i-2]（i > 1）。
            4.  **填表**：按顺序填充dp数组。
            5.  **结果**：dp[n]即为所求的斐波那契数列的第n项。

---

### **5. 贪心算法**

贪心算法在每一步决策时，都采取当前状态下最优（或最有利）的选择，期望通过一系列局部最优选择，最终得到全局最优解。

*   **核心思想**：只顾眼前，做出局部最优选择，不考虑未来影响。
*   **适用前提**：问题必须具有**贪心选择性质**，即局部最优策略能导致全局最优解。
*   **特点**：简单、高效，但并不总是能得到全局最优解，有时只能得到近似解。
*   **经典问题**：
    *   **活动选择问题（区间调度）**：
        *   **问题描述**：有n个活动，每个活动都有一个开始时间si和结束时间fi。目标是安排尽可能多的活动，使得这些活动之间不重叠（即一个活动结束时另一个活动才能开始）。
        *   **步骤**：
            1.  **排序**：将所有活动按照结束时间非递减顺序排序。
            2.  **初始化**：选择第一个活动（结束时间最早的活动），将其加入结果集。
            3.  **选择**：对于剩余的每个活动，如果其开始时间大于或等于上一个选中活动的结束时间，则将其加入结果集。
            4.  **重复**：重复步骤3，直到所有活动都被考虑。
            5.  **结果**：结果集中的活动即为最大数量的不重叠活动。
    
    *   **霍夫曼编码**：
        *   **问题描述**：给定一组字符及其出现频率，为每个字符分配一个二进制编码，使得编码后的字符串长度最短，且没有任何一个字符的编码是另一个字符编码的前缀（前缀编码）。
        *   **步骤**：
            1.  **统计频率**：统计每个字符的出现频率。
            2.  **创建节点**：为每个字符创建一个叶子节点，节点的权重为字符的频率。
            3.  **构建优先队列**：将所有节点按权重从小到大排序，放入优先队列（最小堆）。
            4.  **构建霍夫曼树**：
                *   当优先队列中的节点数大于1时：
                    *   从队列中取出权重最小的两个节点。
                    *   创建一个新的内部节点，其权重为这两个节点权重之和。
                    *   将这两个节点作为新节点的左右子节点。
                    *   将新节点加入优先队列。
            5.  **分配编码**：从根节点开始，向左走标记为0，向右走标记为1，直到到达叶子节点，路径上的标记序列即为该字符的编码。
            6.  **结果**：每个字符的霍夫曼编码即为所求的前缀编码。
    
    *   **分数背包问题**：
        *   **问题描述**：有N件物品和一个容量为W的背包。第i件物品的重量是weight[i]，价值是value[i]。与0-1背包不同的是，这里可以选择物品的一部分，目标是使背包中的物品总价值最大。
        *   **步骤**：
            1.  **计算单位价值**：计算每件物品的单位重量价值（value[i] / weight[i]）。
            2.  **排序**：将所有物品按单位重量价值非递增顺序排序。
            3.  **初始化**：当前背包容量为W，总价值为0。
            4.  **选择**：按顺序考虑每件物品：
                *   如果物品可以完全放入背包（weight[i] <= 剩余容量），则将其全部放入，更新剩余容量和总价值。
                *   否则，将物品的一部分（剩余容量/weight[i]）放入背包，更新剩余容量为0，总价值增加（剩余容量 * 单位价值），并结束算法。
            5.  **结果**：最终的总价值即为所求的最大价值。
    
    *   **最小生成树**（Prim和Kruskal算法也是贪心策略的应用）。

---

### **6. 分治算法**

分治算法将一个大问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题，递归地解决这些子问题，然后将子问题的解合并，得到原问题的解。

*   **基本步骤**：
    1.  **分解**：将原问题分解为若干个子问题。
    2.  **解决**：递归地求解各个子问题。若子问题规模足够小，则直接求解。
    3.  **合并**：将子问题的解合并成原问题的解。
*   **经典应用**：
    *   **归并排序**：
        *   步骤1：**分解**：如果数组长度大于1，则将数组分成两个大致相等的子数组。
        *   步骤2：**解决**：递归地对左子数组进行归并排序。
        *   步骤3：**解决**：递归地对右子数组进行归并排序。
        *   步骤4：**合并**：合并两个已排序的子数组：
            *   创建一个临时数组来存放合并后的结果。
            *   比较两个子数组的第一个元素，将较小的元素放入临时数组，并移动该子数组的指针。
            *   重复上述过程，直到一个子数组中的所有元素都被放入临时数组。
            *   将另一个子数组中剩余的元素全部复制到临时数组。
            *   将临时数组中的元素复制回原数组。
        *   步骤5：**返回**：返回排序后的数组。
    
    *   **快速排序**：
        *   步骤1：**分解**：从数组中选择一个元素作为基准值（pivot）。
        *   步骤2：**分区**：将数组分区，所有小于基准值的元素放在基准值的左边，所有大于基准值的元素放在基准值的右边。基准值位于其最终位置。
        *   步骤3：**解决**：递归地对基准值左边的子数组进行快速排序。
        *   步骤4：**解决**：递归地对基准值右边的子数组进行快速排序。
        *   步骤5：**合并**：由于是原地排序，不需要显式合并。
    
    *   **二分查找**：
        *   步骤1：**分解**：确定查找范围的起始点（low）和结束点（high），初始时low为0，high为数组长度减1。
        *   步骤2：**解决**：计算中间位置mid = low + (high - low) / 2。
        *   步骤3：**合并**：
            *   如果中间元素等于目标值，返回mid。
            *   如果中间元素小于目标值，将low设置为mid + 1，在右半部分继续查找。
            *   如果中间元素大于目标值，将high设置为mid - 1，在左半部分继续查找。
        *   步骤4：**重复**：重复步骤2-3，直到找到目标值或low大于high。
        *   步骤5：**结果**：如果low大于high，说明未找到目标值，返回未找到的标识（如-1）。
    
    *   **大整数乘法**：
        *   **问题描述**：计算两个大整数（可能超出计算机基本数据类型的表示范围）的乘积。
        *   **步骤**（基于Karatsuba算法）：
            1.  **分解**：将两个大整数x和y分别分成两部分：
                *   x = a * 10^(n/2) + b
                *   y = c * 10^(n/2) + d
                其中n是整数的位数，a、b、c、d是n/2位的整数。
            2.  **递归计算**：
                *   计算ac = a * c
                *   计算bd = b * d
                *   计算(a + b) * (c + d) = ac + ad + bc + bd
                *   计算ad + bc = (a + b) * (c + d) - ac - bd
            3.  **合并**：
                *   x * y = ac * 10^n + (ad + bc) * 10^(n/2) + bd
            4.  **返回**：返回计算结果。

---

### **7. 回溯算法**

回溯算法是一种探索性的搜索算法。它通过深度优先搜索的方式，在解空间树中系统地寻找所有可能的解。当发现当前路径不可能找到有效解时，就"回溯"到上一步，尝试其他选择。

*   **核心思想**：走不通就退回。
*   **关键技术**：**剪枝**，即在搜索过程中提前判断并放弃不可能产生解的分支，以提高效率。
*   **经典问题**：
    *   **全排列问题**：
        *   **问题描述**：给定一个不含重复数字的数组nums，返回其所有可能的全排列。
        *   **步骤**：
            1.  **初始化**：创建一个结果列表，用于存储所有排列；创建一个临时列表，用于存储当前排列；创建一个布尔数组，用于标记哪些数字已经被使用。
            2.  **回溯**：
                *   如果临时列表的大小等于nums的大小，说明已经找到一个完整的排列，将其加入结果列表。
                *   否则，遍历nums中的每个数字：
                    *   如果该数字未被使用，将其标记为已使用，加入临时列表。
                    *   递归调用回溯函数。
                    *   回溯：将该数字从临时列表中移除，并标记为未使用。
            3.  **返回**：返回结果列表。
    
    *   **N皇后问题**：
        *   **问题描述**：在N×N的棋盘上放置N个皇后，使得它们互不攻击（即任意两个皇后不在同一行、同一列或同一对角线上）。
        *   **步骤**：
            1.  **初始化**：创建一个N×N的棋盘，初始时所有位置为空；创建一个结果列表，用于存储所有解。
            2.  **回溯**：
                *   如果已经放置了N个皇后，说明找到一个解，将当前棋盘状态加入结果列表。
                *   否则，在当前行的每一列尝试放置皇后：
                    *   检查该位置是否与已放置的皇后冲突（同一列或同一对角线）。
                    *   如果不冲突，在该位置放置皇后。
                    *   递归调用回溯函数，尝试在下一行放置皇后。
                    *   回溯：移除该位置的皇后。
            3.  **返回**：返回结果列表。
    
    *   **数独求解**：
        *   **问题描述**：给定一个9×9的数独棋盘，其中一些格子已经填有数字，其他格子为空。目标是填充所有空格子，使得每行、每列和每个3×3的子网格中都包含1-9的所有数字，且不重复。
        *   **步骤**：
            1.  **初始化**：创建一个9×9的数独棋盘。
            2.  **回溯**：
                *   找到一个空格子（值为0的位置）。
                *   如果没有空格子，说明已经找到一个解，返回true。
                *   对于该空格子，尝试填入1-9的数字：
                    *   检查该数字是否满足数独的规则（行、列和3×3子网格中不重复）。
                    *   如果满足，填入该数字。
                    *   递归调用回溯函数，尝试填充下一个空格子。
                    *   如果递归返回true，说明已经找到解，返回true。
                    *   回溯：将该格子重置为0。
                *   如果所有数字都尝试过但仍未找到解，返回false。
            3.  **结果**：如果回溯函数返回true，则数独有解；否则，数独无解。
    
    *   **组合、子集、分割问题**：
        *   **组合问题**：给定一个整数数组nums和一个整数k，找出所有可能的k个数的组合。
            *   **步骤**：
                1.  **初始化**：创建一个结果列表，用于存储所有组合；创建一个临时列表，用于存储当前组合。
                2.  **回溯**：
                    *   如果临时列表的大小等于k，说明已经找到一个完整的组合，将其加入结果列表。
                    *   否则，从当前位置开始，遍历剩余的数字：
                        *   将当前数字加入临时列表。
                        *   递归调用回溯函数，从下一个位置开始。
                        *   回溯：将当前数字从临时列表中移除。
                3.  **返回**：返回结果列表。
        
        *   **子集问题**：给定一个整数数组nums，返回其所有可能的子集（幂集）。
            *   **步骤**：
                1.  **初始化**：创建一个结果列表，用于存储所有子集；创建一个临时列表，用于存储当前子集。
                2.  **回溯**：
                    *   将当前子集加入结果列表。
                    *   从当前位置开始，遍历剩余的数字：
                        *   将当前数字加入临时列表。
                        *   递归调用回溯函数，从下一个位置开始。
                        *   回溯：将当前数字从临时列表中移除。
                3.  **返回**：返回结果列表。
        
        *   **分割问题**：给定一个字符串s，将s分割成一些子串，使得每个子串都是回文串。返回所有可能的分割方案。
            *   **步骤**：
                1.  **初始化**：创建一个结果列表，用于存储所有分割方案；创建一个临时列表，用于存储当前分割方案。
                2.  **回溯**：
                    *   如果已经处理完整个字符串，将当前分割方案加入结果列表。
                    *   否则，从当前位置开始，尝试所有可能的分割点：
                        *   检查从当前位置到分割点的子串是否是回文串。
                        *   如果是，将该子串加入临时列表。
                        *   递归调用回溯函数，从分割点的下一个位置开始。
                        *   回溯：将该子串从临时列表中移除。
                3.  **返回**：返回结果列表。

---

### **8. 字符串匹配算法**

用于在一个主文本中查找一个或多个模式串出现的位置。

1.  **朴素算法**：
    *   步骤1：**初始化**：设主文本为text，模式串为pattern，n为text的长度，m为pattern的长度。
    *   步骤2：**匹配**：
        *   对于text中的每个可能的起始位置i（0 ≤ i ≤ n - m）：
            *   比较text[i+j]和pattern[j]（0 ≤ j < m）：
                *   如果所有字符都匹配，则找到一个匹配，记录起始位置i。
                *   如果有字符不匹配，则停止比较，尝试下一个起始位置。
    *   步骤3：**结果**：返回所有匹配的起始位置。
    *   **时间复杂度**：O(mn)。

2.  **KMP算法**：
    *   步骤1：**预处理**：构建模式串的next数组（或称为前缀函数）：
        *   创建一个数组next，长度与pattern相同，next[0] = -1。
        *   设i = 0，j = -1。
        *   当i < pattern的长度 - 1时：
            *   如果j == -1或pattern[i] == pattern[j]，则i++，j++，next[i] = j。
            *   否则，j = next[j]。
    *   步骤2：**匹配**：
        *   设i = 0（text的指针），j = 0（pattern的指针）。
        *   当i < text的长度且j < pattern的长度时：
            *   如果j == -1或text[i] == pattern[j]，则i++，j++。
            *   否则，j = next[j]。
            *   如果j == pattern的长度，则找到一个匹配，起始位置为i - j，然后j = next[j]（继续寻找下一个匹配）。
    *   步骤3：**结果**：返回所有匹配的起始位置。
    *   **时间复杂度**：O(m+n)。

3.  **Boyer-Moore算法**：
    *   步骤1：**预处理**：
        *   **坏字符规则**：创建一个坏字符表，记录每个字符在pattern中最右出现的位置。
        *   **好后缀规则**：创建一个好后缀表，记录pattern中每个后缀的最右出现位置。
    *   步骤2：**匹配**：
        *   设i = 0（text的起始位置）。
        *   当i ≤ n - m（n是text的长度，m是pattern的长度）：
            *   从右向左比较text[i+j]和pattern[j]（0 ≤ j < m）：
                *   如果所有字符都匹配，则找到一个匹配，记录起始位置i。
                *   如果有字符不匹配，应用坏字符规则和好后缀规则计算移动距离：
                    *   坏字符规则：如果text[i+j]不在pattern中，则移动距离为j + 1；否则，移动距离为j - badChar[text[i+j]]。
                    *   好后缀规则：如果pattern[j+1..m-1]在pattern的其他位置出现，则移动距离使该后缀对齐；否则，移动距离为m - goodSuffix[0]。
                *   取两个规则中较大的移动距离，更新i = i + max(坏字符移动距离, 好后缀移动距离)。
    *   步骤3：**结果**：返回所有匹配的起始位置。
    *   **特点**：通常在实际应用中效率最高。

4.  **Rabin-Karp算法**：
    *   步骤1：**预处理**：
        *   选择一个质数p作为哈希函数的模数。
        *   计算pattern的哈希值hashPattern。
        *   计算text中第一个长度为m的子串的哈希值hashText。
        *   计算h = p^(m-1) mod p，用于滚动哈希。
    *   步骤2：**匹配**：
        *   对于text中的每个长度为m的子串（起始位置i从0到n - m）：
            *   如果hashText == hashPattern，则逐个字符比较text[i..i+m-1]和pattern：
                *   如果所有字符都匹配，则找到一个匹配，记录起始位置i。
            *   如果i < n - m，计算下一个子串的哈希值：
                *   hashText = (p * (hashText - text[i] * h) + text[i+m]) mod p。
                *   如果hashText为负数，加上p使其为正数。
    *   步骤3：**结果**：返回所有匹配的起始位置。
    *   **特点**：通过哈希函数计算模式串和文本子串的哈希值，比较哈希值来快速筛选可能的匹配，再进行精确验证。

---

### **9. 其他基础算法与技巧**

这些是特定领域的算法或基础的编程技巧。

*   **数论算法**：处理与整数相关的问题，在密码学中有重要应用。
    *   **欧几里得算法**：求最大公约数（GCD）。
        *   **步骤**：
            1.  给定两个正整数a和b，假设a > b。
            2.  计算a除以b的余数r = a mod b。
            3.  如果r == 0，则b即为最大公约数，算法结束。
            4.  否则，令a = b，b = r，返回步骤2。
    
    *   **素数筛法**：高效地找出一定范围内的所有素数。
        *   **步骤**（埃拉托斯特尼筛法）：
            1.  创建一个布尔数组isPrime[0..n]，初始时都设为true。
            2.  isPrime[0] = isPrime[1] = false（0和1不是素数）。
            3.  对于i从2到sqrt(n)：
                *   如果isPrime[i]为true，则i是素数：
                    *   对于j从i*i到n，步长为i：
                        *   isPrime[j] = false（j是i的倍数，不是素数）。
            4.  所有isPrime[i]为true的i即为素数。
    
    *   **快速幂算法**：高效计算a^b。
        *   **步骤**：
            1.  给定底数a，指数b和模数m（可选）。
            2.  初始化结果res = 1。
            3.  当b > 0：
                *   如果b是奇数，则res = res * a（如果需要模运算，则res = (res * a) mod m）。
                *   a = a * a（如果需要模运算，则a = (a * a) mod m）。
                *   b = b / 2（整数除法）。
            4.  返回res。

*   **位运算**：直接对整数的二进制位进行操作，常用于优化和实现底层功能。
    *   **判断奇偶**：
        *   **步骤**：检查数字的最低位是否为1，即num & 1。如果结果为1，则是奇数；否则，是偶数。
    
    *   **交换两数**：
        *   **步骤**：
            1.  a = a ^ b。
            2.  b = a ^ b（此时b = a）。
            3.  a = a ^ b（此时a = b）。
    
    *   **计算汉明重量**（二进制中1的个数）：
        *   **步骤**：
            1.  初始化计数器count = 0。
            2.  当num > 0：
                *   count = count + (num & 1)。
                *   num = num >> 1（右移一位）。
            3.  返回count。
    
    *   **判断是否为2的幂次**：
        *   **步骤**：检查num & (num - 1)是否等于0。如果等于0且num > 0，则是2的幂次。